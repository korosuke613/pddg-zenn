---
title: "はじめに"
---

## 本書の対象者

- ビルドシステムやモノレポに興味がある人
- BazelとGoの組み合わせに興味がある人
- 大規模なGoプロジェクトでビルドやテストの時間に悩んでいる人

## 本書の内容を実践するにあたり必要な物

- 作業用のPC 1台
  - Mac、Linux、もしくはWSL2が使えるWindowsのマシン

## なぜモノレポを採用したいか

モノレポとは、複数のプロジェクトを1つのリポジトリで管理する手法です。モノレポ構成を採用することで、以下のようなメリットが得られると筆者は考えています[^monorepo]。

[^monorepo]: これは [Advantages and Disadvantages of a Monolithic Codebase](https://research.google/pubs/advantages-and-disadvantages-of-a-monolithic-codebase/) を読んだり、自分自身の開発経験から来る意見です。全てのケースでこれらが当てはまるとは限りません。

### コード共有が容易になる

多くのプロジェクトを抱える企業のリポジトリでは、リポジトリを跨いで同じようなコードが複数存在します。モノレポではこれらのコードは既にリポジトリ内にあるため、新しいプロダクトやライブラリを開発する際に再利用しやすくなります。

複数のリポジトリで似たようなコードを再生産しないよう、共有ライブラリが整備されることもあります。これはうまくワークすることもありますが、利用するチームと開発するチームが分かれていると、共有ライブラリが正しく更新されず古いまま使われたりすることもあります。モノレポであれば、共有ライブラリの管理チームはリポジトリ内のコードを単に更新するだけで他のチームも自動的に最新のコードを利用できます。共有ライブラリを更新するPull Requestをあらゆるリポジトリに送る必要はなくなります。

既に実績のあるライブラリなどがリポジトリに実装されていれば、新しい機能や新しいアプリケーションの開発を始める際、それらの開発の本質へと集中できるようになります。

### 依存関係管理が容易になる

全てのコードが同じリポジトリ内にあるため、どのアプリケーション・ライブラリが何に依存しているのかがリポジトリ内の検索のみでわかります。これは仕様変更やバグ修正の際、その変更がどのアプリケーションに影響を与えるかを把握しやすくなることを意味します。特にgRPCやProtocol Buffersを用いてスキーマファーストで開発している場合、APIを介して依存するアプリケーションを探すことが容易になります。

このような利点は脆弱性の管理にも有効です。セキュリティに責任を持つチームは、リポジトリ内にあるサードパーティ製のライブラリに関する脆弱性を検知したとき、リポジトリ内のどのアプリケーションがそのライブラリを利用しているかをすぐに把握できます。また、その脆弱性を修正するために必要な修正をリポジトリ内の全てのアプリケーションに適用することも容易になります。

### 開発プロセスの標準化が容易になる

モノレポではチームを跨いで同じリポジトリ・ツールを扱うことになるでしょう。そのため、チームごとの開発プロセスを統一することに大きなインセンティブが生まれます。これは、コードレビューのプロセスやCI/CDの設定、コードフォーマットの設定など、開発プロセスの標準化につながります。

開発プロセスが同じなのであれば、他のチームのコードを修正することも普段の開発の延長のように行えるはずです。他のチームのコードに問題を見つけた場合や、こういった機能を追加して欲しいといった提案をより容易に行うことができるでしょう。

## なぜモノレポが採用されないか

いくつか利点を挙げましたが、実際にはモノレポは日本においてそれほど採用されている手法であるとは感じていません。
これは様々な理由が考えられますが、一般には以下のような理由が挙げられると考えています。

### 変更のコンフリクトが発生しやすい

特にfeature branchを用いるような開発スタイルでは、1つのブランチの生存期間が長くなりがちです。このような場合、その間に他のチームが変更を加えることでコンフリクトが発生しやすくなります。

解決策としては、そもそも開発のスタイルを大きく変えていく必要があります。例えばモノレポを採用するGoogleではいわゆる[トランクベース開発](https://dora.dev/capabilities/trunk-based-development/)と呼ばれるスタイルを採用しています。これは変更を小さく切り分けてメインブランチにマージしていくため、コンフリクトを最小限に抑えられます。
しかし、これまでfeature branchを用いて開発してきたチームにとって、こういったスタイルへの乗り換えは一般に困難です。開発そのものだけでなく、開発環境や品質管理のプロセスにもこれらは影響を与えるためです。
また、マージした変更のリリースをマージではないものでトリガーする必要があり、多くの場合feature flagが用いられます。開発スタイルの変更に加えて新しい概念の導入も必要となるのです。

### ビルドやテストにかかる時間が長くなる

全てのコードが同じリポジトリ内にあるということは、そのCI/CDパイプラインにおいてある変更がpushされたとき、全てのコードがビルド・テストの対象になりうるということを意味します。これは小さなリポジトリに分割した構成と比べて、ビルドやテストにかかる時間が長くなることを意味します。
変更に対して無関係なビルド・テストは実行しなければよいのですが、これを実現するのは難しいことが原因でしょう。GitHub Actionsでは特定の種類のファイルに変更があった場合のみ実行する、といった設定も行えますが、これを完璧に維持することは難しいでしょう。

## Bazelがモノレポに向いている理由

Bazelは単なるビルドツールです。しかし、そもそもGoogleが内部で利用するビルドツールであるBlazeのオープンソース版であり[^blaze]、その機能はモノレポを前提として設計されています。

[^blaze]: <https://bazel.build/versions/7.4.0/basics/artifact-based-builds#understanding_artifact-based_build_systems>

先ほど述べたように、モノレポではビルドやテストが長時間化しやすくなります。Bazelはこの問題に対して、並列化やキャッシュの利用、ビルドの依存関係の解析などを行うことで、ビルドの高速化を実現しています。つまり、変更があったときにその変更が影響する範囲のみをビルド・テストする機能を備えています。

ビルドツールは他にも複数あります。例えば[Gradle](https://gradle.org/)です。Gradleもビルドの並列化やキャッシュを利用できますが、基本的にはJava/Kotlin/ScalaなどのJVM言語向けに設計されています。他の言語（Goなど）を使いたいユーザがGradleを採用することはないでしょう。[Turborepo](https://turbo.build/repo/docs)は比較的最近に登場したモノレポ用のツールですが、これもJavaScript/TypeScript向けに特化したものです。言語を問わず利用できるビルドツールとなるためには、ユーザやコミュニティがその機能を拡張できる必要がありますが、これらのツールはその機能が乏しいと言えるでしょう。

言語を問わないビルドツールとしては、他にFacebookが開発する[Buck2](https://buck2.build/)や旧Twitter社の[Pants](https://www.pantsbuild.org/)があります。ドキュメントなどを読むと分かるのですが、Bazel・Buck2・Pantsはいずれも[Starlark](https://github.com/bazelbuild/starlark)というDSLを用いてビルドを定義し、ビルドの依存関係を明示したり、出力するアーティファクトを宣言しています。これらのツールにはそれぞれの思想があり、扱い方には違いはあるものの、その根底となる概念は似通ったものを採用しています。Bazelはおそらく（筆者の主観では）最もコミュニティ層が厚く、まずはBazelを試してみるというのは悪い選択肢ではないと考えます。

## Bazelのその他の重要な特徴

### アーティファクトベースのビルド

GradleやMavenなどのビルドツールとの最も大きな違いは、そのビルドの記述方法にあります。GradleやMaven、Turborepoもそうですが、ビルドの設定には「何をするか」という手続きが書かれます。手続きに対して名前をつけ、開発者は特定の手続きを呼び出すことでビルドを行います。

一方、Bazelは「何を生成するか」を記述します。その具体的な手続きは隠蔽されており、ユーザは生成したいアーティファクトを指定してビルドします。これによりBazelは指定されたアーティファクトおよびその依存を解析し、可能な限り並列にそれらをビルドできます。隠蔽されたビルドの実際の手続きはそのプロフェッショナルがメンテナンスすることで、一般的な開発者は単に提供されたルールを使ってアーティファクトを生成できます。

詳しくは以下のドキュメントを参照して下さい。

@[card](https://bazel.build/versions/7.4.0/basics/artifact-based-builds)

### ビルドの再現性

Bazelはビルドの再現性を重視しています。基本的にはビルドという操作は、何らかの入力から出力を生成する純粋関数として捉えられています。キャッシュの仕組みなどもその前提に基づいて設計されており、入力が変わらないならビルドという操作をスキップしてその出力結果を返しても問題ないという考え方がされています。

そのため、Bazelはビルド時にその依存を解析し、必要なファイルのみが存在する閉鎖された環境でビルドを行います。このような環境でのビルドは密閉された（hermeticな）ビルドと呼ばれます。

例えば開発者の手元の環境に、リポジトリにコミットされておらずBazelから認識されていないファイルがあったとします。通常のビルドツールではこのようなファイルもビルドに影響を与える可能性がありますが、Bazelはビルド時にそのファイルからビルド対象は隔離された環境でビルドされるため、影響を受けません。
他にも、ユーザごとに異なるバージョンのGoコンパイラを利用している可能性があります。Bazelはビルド時に利用するGoのバージョンをBazelの設定として記述するため、ユーザの環境に依存することなくビルドを行うことができます。

これはDockerによるmulti stage buildと似ていると感じた人もいるかもしれません。実際に似た点もあると思います。しかし、BazelはDockerfileにおけるいくつかの問題（キャッシュの利用、ネットワークごしにアクセスするアーティファクトへの依存）に対してより厳格なアプローチを取っています。そのため人によっては自由が制限されると感じることもあるかもしれませんが、これはビルドの再現性を重視するためのものです。

詳しくは以下のドキュメントを参照して下さい。

@[card](https://bazel.build/versions/7.4.0/basics/hermeticity)

## まとめ

モノレポとは何か、なぜ採用したいのか、なぜ採用されないのか、Bazelがモノレポに向いている理由、Bazelのその他の重要な特徴について解説しました。
Bazelは複雑と言われ、実際に通常の開発フローとは異なる部分が多いです。しかし、それはビルドの再現性やビルドの高速化を実現するためのものであると理解することが重要です。
次章から、実際にBazelを使ってGoを使ったアプリケーションのビルド方法を紹介します。
